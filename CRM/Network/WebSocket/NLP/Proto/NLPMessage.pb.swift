// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: NLPMessage.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct NLPMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///required
  public var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  ///required
  public var messageID: Int64 {
    get {return _storage._messageID}
    set {_uniqueStorage()._messageID = newValue}
  }

  /// false = -1 | 0 - undefined | true = 1 // default=false //required
  public var last: Int32 {
    get {return _storage._last}
    set {_uniqueStorage()._last = newValue}
  }

  ///optional
  public var token: String {
    get {return _storage._token}
    set {_uniqueStorage()._token = newValue}
  }

  ///required
  public var userChannel: String {
    get {return _storage._userChannel}
    set {_uniqueStorage()._userChannel = newValue}
  }

  ///optional
  public var vpsToken: String {
    get {return _storage._vpsToken}
    set {_uniqueStorage()._vpsToken = newValue}
  }

  ///optional
  public var devContext: [NLPDevContext] {
    get {return _storage._NLPDevContext}
    set {_uniqueStorage()._NLPDevContext = newValue}
  }

  ///optional
  public var messageName: String {
    get {return _storage._messageName}
    set {_uniqueStorage()._messageName = newValue}
  }
    
    var content: OneOf_Content? {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  public var voice: NLPVoice {
    get {
      if case .voice(let v)? = _storage._content {return v}
      return NLPVoice()
    }
    set {_uniqueStorage()._content = .voice(newValue)}
  }

  public var text: NLPText {
    get {
      if case .text(let v)? = _storage._content {return v}
      return NLPText()
    }
    set {_uniqueStorage()._content = .text(newValue)}
  }

  /// JSON as String.
  public var systemMessage: NLPSystemMessage {
    get {
      if case .systemMessage(let v)? = _storage._content {return v}
      return NLPSystemMessage()
    }
    set {_uniqueStorage()._content = .systemMessage(newValue)}
  }

  public var device: NLPDevice {
    get {
      if case .device(let v)? = _storage._content {return v}
      return NLPDevice()
    }
    set {_uniqueStorage()._content = .device(newValue)}
  }

  public var settings: NLPSettings {
    get {
      if case .settings(let v)? = _storage._content {return v}
      return NLPSettings()
    }
    set {_uniqueStorage()._content = .settings(newValue)}
  }

  public var status: NLPStatus {
    get {
      if case .status(let v)? = _storage._content {return v}
      return NLPStatus()
    }
    set {_uniqueStorage()._content = .status(newValue)}
  }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Content: Equatable {
    case voice(NLPVoice)
    case text(NLPText)
    /// JSON as String.
    case systemMessage(NLPSystemMessage)
    case device(NLPDevice)
    case settings(NLPSettings)
    case status(NLPStatus)

  #if !swift(>=4.1)
    static func ==(lhs: NLPMessage.OneOf_Content, rhs: NLPMessage.OneOf_Content) -> Bool {
      switch (lhs, rhs) {
      case (.voice(let l), .voice(let r)): return l == r
      case (.text(let l), .text(let r)): return l == r
      case (.systemMessage(let l), .systemMessage(let r)): return l == r
      case (.device(let l), .device(let r)): return l == r
      case (.settings(let l), .settings(let r)): return l == r
      case (.status(let l), .status(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

    public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct NLPDevice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clientType: String = String()

  public var channel: String = String()

  public var channelVersion: String = String()

  public var platformName: String = String()

  public var platformVersion: String = String()

  public var sdkVersion: String = String()

  public var protocolVersion: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct NLPVoice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Data = SwiftProtobuf.Internal.emptyData

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct NLPText {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct NLPSystemMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct NLPSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// false = -1 | 0 - undefined | true = 1 // default:true
  public var dubbing: Int32 = 0

  /// false = -1 | 0 - undefined | true = 1 // default:false
  public var echo: Int32 = 0

  /// tts engine alias
  public var ttsEngine: String = String()

  /// stt engine alias
  public var sttEngine: String = String()

  public var sttAutoStop: Int32 = 0

  /// trace enabler
  public var devMode: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct NLPStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Int32 = 0

  public var description_p: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct NLPDevContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var timestampMs: Int64 = 0

  public var data: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension NLPMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "NLPMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "message_id"),
    3: .same(proto: "last"),
    4: .same(proto: "token"),
    11: .standard(proto: "user_channel"),
    12: .standard(proto: "vps_token"),
    13: .standard(proto: "dev_context"),
    14: .standard(proto: "message_name"),
    5: .same(proto: "voice"),
    6: .same(proto: "text"),
    7: .standard(proto: "system_message"),
    8: .same(proto: "device"),
    9: .same(proto: "settings"),
    10: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    public var _userID: String = String()
    public var _messageID: Int64 = 0
    public var _last: Int32 = 0
    public var _token: String = String()
    public var _userChannel: String = String()
    public var _vpsToken: String = String()
    public var _NLPDevContext: [NLPDevContext] = []
    public var _messageName: String = String()
    public var _content: NLPMessage.OneOf_Content?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _userID = source._userID
      _messageID = source._messageID
      _last = source._last
      _token = source._token
      _userChannel = source._userChannel
      _vpsToken = source._vpsToken
      _NLPDevContext = source._NLPDevContext
      _messageName = source._messageName
      _content = source._content
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

    mutating public func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._userID)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._messageID)
        case 3: try decoder.decodeSingularInt32Field(value: &_storage._last)
        case 4: try decoder.decodeSingularStringField(value: &_storage._token)
        case 5:
            var v: NLPVoice?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .voice(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .voice(v)}
        case 6:
            var v: NLPText?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .text(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .text(v)}
        case 7:
          var v: NLPSystemMessage?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .systemMessage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .systemMessage(v)}
        case 8:
          var v: NLPDevice?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .device(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .device(v)}
        case 9:
          var v: NLPSettings?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .settings(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .settings(v)}
        case 10:
          var v: NLPStatus?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .status(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .status(v)}
        case 11: try decoder.decodeSingularStringField(value: &_storage._userChannel)
        case 12: try decoder.decodeSingularStringField(value: &_storage._vpsToken)
        case 13: try decoder.decodeRepeatedMessageField(value: &_storage._NLPDevContext)
        case 14: try decoder.decodeSingularStringField(value: &_storage._messageName)
        default: break
        }
      }
    }
  }

    public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 1)
      }
      if _storage._messageID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._messageID, fieldNumber: 2)
      }
      if _storage._last != 0 {
        try visitor.visitSingularInt32Field(value: _storage._last, fieldNumber: 3)
      }
      if !_storage._token.isEmpty {
        try visitor.visitSingularStringField(value: _storage._token, fieldNumber: 4)
      }
      switch _storage._content {
      case .voice(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .text(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .systemMessage(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .device(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .settings(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .status(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case nil: break
      }
      if !_storage._userChannel.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userChannel, fieldNumber: 11)
      }
      if !_storage._vpsToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._vpsToken, fieldNumber: 12)
      }
      if !_storage._NLPDevContext.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._NLPDevContext, fieldNumber: 13)
      }
      if !_storage._messageName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._messageName, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

    public static func ==(lhs: NLPMessage, rhs: NLPMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._messageID != rhs_storage._messageID {return false}
        if _storage._last != rhs_storage._last {return false}
        if _storage._token != rhs_storage._token {return false}
        if _storage._userChannel != rhs_storage._userChannel {return false}
        if _storage._vpsToken != rhs_storage._vpsToken {return false}
        if _storage._NLPDevContext != rhs_storage._NLPDevContext {return false}
        if _storage._messageName != rhs_storage._messageName {return false}
        if _storage._content != rhs_storage._content {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NLPDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "NLPDevice"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_type"),
    2: .same(proto: "channel"),
    3: .standard(proto: "channel_version"),
    4: .standard(proto: "platform_name"),
    5: .standard(proto: "platform_version"),
    6: .standard(proto: "sdk_version"),
    7: .standard(proto: "protocol_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.clientType)
      case 2: try decoder.decodeSingularStringField(value: &self.channel)
      case 3: try decoder.decodeSingularStringField(value: &self.channelVersion)
      case 4: try decoder.decodeSingularStringField(value: &self.platformName)
      case 5: try decoder.decodeSingularStringField(value: &self.platformVersion)
      case 6: try decoder.decodeSingularStringField(value: &self.sdkVersion)
      case 7: try decoder.decodeSingularStringField(value: &self.protocolVersion)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientType.isEmpty {
      try visitor.visitSingularStringField(value: self.clientType, fieldNumber: 1)
    }
    if !self.channel.isEmpty {
      try visitor.visitSingularStringField(value: self.channel, fieldNumber: 2)
    }
    if !self.channelVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.channelVersion, fieldNumber: 3)
    }
    if !self.platformName.isEmpty {
      try visitor.visitSingularStringField(value: self.platformName, fieldNumber: 4)
    }
    if !self.platformVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.platformVersion, fieldNumber: 5)
    }
    if !self.sdkVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.sdkVersion, fieldNumber: 6)
    }
    if !self.protocolVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.protocolVersion, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

    public static func ==(lhs: NLPDevice, rhs: NLPDevice) -> Bool {
    if lhs.clientType != rhs.clientType {return false}
    if lhs.channel != rhs.channel {return false}
    if lhs.channelVersion != rhs.channelVersion {return false}
    if lhs.platformName != rhs.platformName {return false}
    if lhs.platformVersion != rhs.platformVersion {return false}
    if lhs.sdkVersion != rhs.sdkVersion {return false}
    if lhs.protocolVersion != rhs.protocolVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NLPVoice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "NLPVoice"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.data)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NLPVoice, rhs: NLPVoice) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NLPText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "NLPText"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.data)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NLPText, rhs: NLPText) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NLPSystemMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "NLPSystemMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.data)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NLPSystemMessage, rhs: NLPSystemMessage) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NLPSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "NLPSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dubbing"),
    2: .same(proto: "echo"),
    3: .standard(proto: "tts_engine"),
    4: .standard(proto: "stt_engine"),
    5: .standard(proto: "stt_auto_stop"),
    6: .standard(proto: "dev_mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.dubbing)
      case 2: try decoder.decodeSingularInt32Field(value: &self.echo)
      case 3: try decoder.decodeSingularStringField(value: &self.ttsEngine)
      case 4: try decoder.decodeSingularStringField(value: &self.sttEngine)
      case 5: try decoder.decodeSingularInt32Field(value: &self.sttAutoStop)
      case 6: try decoder.decodeSingularInt32Field(value: &self.devMode)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dubbing != 0 {
      try visitor.visitSingularInt32Field(value: self.dubbing, fieldNumber: 1)
    }
    if self.echo != 0 {
      try visitor.visitSingularInt32Field(value: self.echo, fieldNumber: 2)
    }
    if !self.ttsEngine.isEmpty {
      try visitor.visitSingularStringField(value: self.ttsEngine, fieldNumber: 3)
    }
    if !self.sttEngine.isEmpty {
      try visitor.visitSingularStringField(value: self.sttEngine, fieldNumber: 4)
    }
    if self.sttAutoStop != 0 {
      try visitor.visitSingularInt32Field(value: self.sttAutoStop, fieldNumber: 5)
    }
    if self.devMode != 0 {
      try visitor.visitSingularInt32Field(value: self.devMode, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NLPSettings, rhs: NLPSettings) -> Bool {
    if lhs.dubbing != rhs.dubbing {return false}
    if lhs.echo != rhs.echo {return false}
    if lhs.ttsEngine != rhs.ttsEngine {return false}
    if lhs.sttEngine != rhs.sttEngine {return false}
    if lhs.sttAutoStop != rhs.sttAutoStop {return false}
    if lhs.devMode != rhs.devMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NLPStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "NLPStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.code)
      case 2: try decoder.decodeSingularStringField(value: &self.description_p)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NLPStatus, rhs: NLPStatus) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NLPDevContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "NLPDevContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "timestamp_ms"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularInt64Field(value: &self.timestampMs)
      case 3: try decoder.decodeSingularStringField(value: &self.data)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.timestampMs != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampMs, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: NLPDevContext, rhs: NLPDevContext) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.timestampMs != rhs.timestampMs {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
